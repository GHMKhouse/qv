
import nimgl/[opengl, glfw]
import glm
import std/[streams, math, monotimes, strformat,os]
import readcht, initchart, shaders, types, globals, audio, font, aff2cht,unirender
var dest=0
var keyn=0
proc keyProc(window: GLFWWindow, key: int32, scancode: int32, action: int32,
    mods: int32): void {.cdecl.} =
  case action
  of GLFWPress:
    case key
    of GLFWKey.Escape:
      # how to pause?
      # echo combo," ",maxCombo," ",xExact," ",exact," ",fine," ",good," ",lost," ",acc
      quit(QuitSuccess)
    of GLFWKey.Home:
      dest=1
    else:
      inc keyn
      while true:
        if (not autoPlay) and judgedNotes < chart.notes.len:
          let
            igt=(time-startTime)/1_000_000_000-chart.offset
            dt = abs(igt-chart.notes[
                judgedNotes].t1)
          case chart.notes[judgedNotes].kind
          of 0:  
            if dt <= 0.016*judgeFactor:
              inc combo
              maxCombo = max(maxCombo, combo)
              inc xExact
              acc = (acc*judgedNotes.float+1)/(judgedNotes+1).float
              chart.notes[judgedNotes].judged = 1
              particles[particleIndex]=Particle(
                time:igt,x:chart.notes[judgedNotes].x1,
                width:chart.notes[judgedNotes].width.float32/255,
                r:0,g:255,b:255
              )
              particleIndex = (particleIndex+1) and 0xff
              inc judgedNotes
            elif dt <= 0.032*judgeFactor:
              inc combo
              maxCombo = max(maxCombo, combo)
              inc exact
              acc = (acc*judgedNotes.float+1)/(judgedNotes+1).float
              chart.notes[judgedNotes].judged = 1
              particles[particleIndex]=Particle(
                time:igt,x:chart.notes[judgedNotes].x1,
                width:chart.notes[judgedNotes].width.float32/255,
                r:0,g:128,b:128
              )
              particleIndex = (particleIndex+1) and 0xff
              inc judgedNotes
            elif dt <= 0.048*judgeFactor:
              inc combo
              maxCombo = max(maxCombo, combo)
              inc fine
              acc = (acc*judgedNotes.float+0.75)/(judgedNotes+1).float
              chart.notes[judgedNotes].judged = 1
              particles[particleIndex]=Particle(
                time:igt,x:chart.notes[judgedNotes].x1,
                width:chart.notes[judgedNotes].width.float32/255,
                r:0,g:255,b:0
              )
              particleIndex = (particleIndex+1) and 0xff
              inc judgedNotes
            elif dt <= 0.064*judgeFactor: # no combo increasement or reset
              inc good
              acc = (acc*judgedNotes.float+0.5)/(judgedNotes+1).float
              chart.notes[judgedNotes].judged = 1
              particles[particleIndex]=Particle(
                time:igt,x:chart.notes[judgedNotes].x1,
                width:chart.notes[judgedNotes].width.float32/255,
                r:255,g:255,b:0
              )
              particleIndex = (particleIndex+1) and 0xff
              inc judgedNotes
            if dt <= 0.064*judgeFactor:
              # echo combo," ",maxCombo," ",xExact," ",exact," ",fine," ",good," ",lost," ",acc
              glBindBuffer(GL_ARRAY_BUFFER, chart.ibo)
              var ptrNote = glMapBufferRange(GL_ARRAY_BUFFER, (
                  judgedNotes-1)*sizeof(Note), sizeof(Note), GL_MAP_WRITE_BIT or GL_MAP_INVALIDATE_RANGE_BIT)
              copyMem(ptrNote, chart.notes[judgedNotes-1].addr, sizeof(Note))
              discard glUnmapBuffer(GL_ARRAY_BUFFER)
          of 1:
            if dt <= 0.032*judgeFactor:
              inc combo
              maxCombo = max(maxCombo, combo)
              inc xExact
              chart.notes[judgedNotes].judged = 1
              particles[particleIndex]=Particle(
                time:igt,x:chart.notes[judgedNotes].x1,
                width:chart.notes[judgedNotes].width.float32/255,
                r:0,g:255,b:255
              )
              particleIndex = (particleIndex+1) and 0xff
              inc judgedNotes
              # echo combo," ",maxCombo," ",xExact," ",exact," ",fine," ",good," ",lost," ",acc
              glBindBuffer(GL_ARRAY_BUFFER, chart.ibo)
              var ptrNote = glMapBufferRange(GL_ARRAY_BUFFER, (
                  judgedNotes-1)*sizeof(Note), sizeof(Note), GL_MAP_WRITE_BIT or GL_MAP_INVALIDATE_RANGE_BIT)
              copyMem(ptrNote, chart.notes[judgedNotes-1].addr, sizeof(Note))
              discard glUnmapBuffer(GL_ARRAY_BUFFER)
              continue
          else:
            discard
        break
  of GLFWRelease:
    if key!=GLFWKey.Escape:
      dec keyn
  else:
    discard


const
  linePos = -0.667
proc gameplay*(): State =
  # discard window.setKeyCallback(keyProc)
  dest=0
  var
    verts: array[8, GLfloat] = [-1, -1, -1, 1, 1, 1, 1, -1]
    inds: array[6, Gluint] = [0, 1, 2, 2, 3, 0]
  var lineRI:RenderInstance
  initRenderInstance(lineRI,inds,[(@[(rFloat,2,0)],2*sizeof(GLfloat))],0,lineShader,["uMVP","uLinePos"])
  lineRI.updateBuffer(0,8*sizeof(GLfloat),verts[0].addr)
  # var
  #   linevao, linevbo, lineebo: GLuint
  # 
  # glGenVertexArrays(1, linevao.addr)
  # glBindVertexArray(linevao)
  # glGenBuffers(1, linevbo.addr)
  # glGenBuffers(1, lineebo.addr)
  # defer:
  #   glDeleteBuffers(1, linevbo.addr)
  #   glDeleteBuffers(1, lineebo.addr)
  #   glDeleteVertexArrays(1, linevao.addr)
  # glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, lineebo)
  # glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6*sizeof(GLuint), inds[0].addr, GL_STATIC_DRAW)
  # glBindBuffer(GL_ARRAY_BUFFER, linevbo)
  # glBufferData(GL_ARRAY_BUFFER, 8*sizeof(GLfloat), verts[0].addr, GL_STATIC_DRAW)
  # glVertexAttribPointer(0, 2, EGL_FLOAT, false, 2*sizeof(GLfloat), nil)
  # glEnableVertexAttribArray(0)
  # glBindBuffer(GL_ARRAY_BUFFER, 0)
  # glBindVertexArray(0)
  var particleRI:RenderInstance
  initRenderInstance(particleRI,inds,[
    (@[(rFloat,2,0)],2*sizeof(GLfloat)),
    (@[(rFloat,3,1),(rUByte,3,1)],sizeof(Particle))],0,particleShader,["uMVP","uLinePos","uTime"])
  particleRI.updateBuffer(0,8*sizeof(GLfloat),verts[0].addr)
  # particleRI.initBuffer(1,256*sizeof(Particle),GL_MAP_WRITE_BIT or GL_MAP_PERSISTENT_BIT or GL_MAP_COHERENT_BIT)
  # var
  #   ptcvao, ptcvbo, ptcebo, ptcibo: GLuint

  # glGenVertexArrays(1, ptcvao.addr)
  # glBindVertexArray(ptcvao)
  # glGenBuffers(1, ptcvbo.addr)
  # glGenBuffers(1, ptcebo.addr)
  # glGenBuffers(1, ptcibo.addr)
  # defer:
  #   glDeleteBuffers(1, ptcvbo.addr)
  #   glDeleteBuffers(1, ptcebo.addr)
  #   glDeleteVertexArrays(1, ptcvao.addr)
  # glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ptcebo)
  # glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6*sizeof(GLuint), inds[0].addr, GL_STATIC_DRAW)
  # glBindBuffer(GL_ARRAY_BUFFER, ptcvbo)
  # glBufferData(GL_ARRAY_BUFFER, 8*sizeof(GLfloat), verts[0].addr, GL_STATIC_DRAW)
  # glVertexAttribPointer(0, 2, EGL_FLOAT, false, 2*sizeof(GLfloat), nil)
  # glEnableVertexAttribArray(0)
  # glBindBuffer(GL_ARRAY_BUFFER, ptcibo)
  # glBufferStorage(GL_ARRAY_BUFFER, 256*sizeof(Particle), nil,
  #     GL_MAP_WRITE_BIT or GL_MAP_PERSISTENT_BIT or GL_MAP_COHERENT_BIT)
  # withBuffer particleRI,1:
  #   particles = cast[ptr array[256, Particle]](glMapBufferRange(GL_ARRAY_BUFFER,
  #       0, 256*sizeof(Particle), GL_MAP_WRITE_BIT or GL_MAP_PERSISTENT_BIT or
  #       GL_MAP_COHERENT_BIT))
  particles=cast[ptr array[256, Particle]](alloc(256*sizeof(Particle)))
  for p in particles[].mitems():
    p = Particle.default
  particleRI.updateBuffer(1,256*sizeof(Particle),particles)
  # defer:
  #   withBuffer particleRI,1:
  #     discard glUnmapBuffer(GL_ARRAY_BUFFER)
  # glVertexAttribPointer(1, 3, EGL_FLOAT, false, sizeof(Particle).GLsizei, nil)
  # glVertexAttribDivisor(1, 1)
  # glEnableVertexAttribArray(1)
  # glVertexAttribIPointer(2, 3, GL_UNSIGNED_BYTE, sizeof(Particle).GLsizei, cast[
  #     pointer](sizeof(float32)*3))
  # glVertexAttribDivisor(2, 1)
  # glEnableVertexAttribArray(2)

  # glBindBuffer(GL_ARRAY_BUFFER, 0)
  # glBindVertexArray(0)

  block readChart:
    # var s = openFileStream("maps"/chartPath/"chart.cht", fmRead)
    # defer: s.close()
    # readCht(chart, s)
    var s = openFileStream("maps"/chartPath/"extradimensional_4.aff", fmRead)
    defer: s.close()
    readAff(s,chart)
    chart.title="Extradimensional Cosmic Phenomenon"
    chart.level="ETR 11?"
  initChart(chart)
  (judgedNotes, combo, maxCombo, xExact, exact, fine, good, lost) = (0,0,0,0,0,0,0,0)
  loadMusic("maps"/chartPath/"music.wav")
  
  var
    titleText, levelText: TextInstance
  initTextInstance(titleText, chart.title)
  defer: destroyTextInstance(titleText)
  initTextInstance(levelText, chart.level)
  defer: destroyTextInstance(levelText)
  var
    accText,comboText: TextInstance
  initTextInstance(accText, "100.00%")
  defer: destroyTextInstance(accText)
  initTextInstance(comboText, "           0")
  defer: destroyTextInstance(comboText)
  var
    mvp = ortho[GLfloat](-1, 1, -1, 1, -1, 1)
    uMVP = glGetUniformLocation(noteShader, "uMVP")
    uXSF = glGetUniformLocation(noteShader, "uXSF")
    uSpeed = glGetUniformLocation(noteShader, "uSpeed")
    uFloor = glGetUniformLocation(noteShader, "uFloor")
    uLinePos = glGetUniformLocation(noteShader, "uLinePos")
  lastTime = getMonoTime().ticks()
  startTime = lastTime
  time = lastTime
  var endPlayTime=lastTime
  playMusic()
  while time-endPlayTime<1_000_000_000 and not window.windowShouldClose():
    if time-lastTime >= 16_000_000:
      let
        igt = (time-startTime)/1_000_000_000-chart.offset
        floor = convertFloor(igt, chart.events)
      if judgedNotes < chart.notes.len:
        if autoPlay:
          while judgedNotes < chart.notes.len and chart.notes[
              judgedNotes].t1-igt < 0.004:
            inc combo
            maxCombo = max(maxCombo, combo)
            inc xExact
            acc = (acc*judgedNotes.float+1)/(judgedNotes+1).float
            chart.notes[judgedNotes].judged = 1
            particles[particleIndex]=Particle(
              time:igt,x:chart.notes[judgedNotes].x1,
              width:chart.notes[judgedNotes].width.float32/255,
              r:255,g:255,b:255
            )
            particleIndex = (particleIndex+1) and 0xff
            inc judgedNotes
            glBindBuffer(GL_ARRAY_BUFFER, chart.ibo)
            var ptrNote = glMapBufferRange(GL_ARRAY_BUFFER, (
                judgedNotes-1)*sizeof(Note), sizeof(Note), GL_MAP_WRITE_BIT or GL_MAP_INVALIDATE_RANGE_BIT)
            copyMem(ptrNote, chart.notes[judgedNotes-1].addr, sizeof(Note))
            discard glUnmapBuffer(GL_ARRAY_BUFFER)
        else:
          var
            catchingNotes=judgedNotes
            caughtNotes=0
          while catchingNotes < chart.notes.len and chart.notes[
              catchingNotes].t1-igt < -0.004:
                if chart.notes[catchingNotes].judged==1:
                  inc catchingNotes
                  continue
                if chart.notes[catchingNotes].kind==1:
                  if keyn>caughtNotes:
                    inc combo
                    maxCombo = max(maxCombo, combo)
                    inc xExact
                    chart.notes[catchingNotes].judged = 1
                    particles[particleIndex]=Particle(
                      time:igt,x:chart.notes[catchingNotes].x1,
                      width:chart.notes[catchingNotes].width.float32/255,
                      r:0,g:255,b:255
                    )
                    particleIndex = (particleIndex+1) and 0xff
                    inc catchingNotes
                    inc caughtNotes
                    # echo combo," ",maxCombo," ",xExact," ",exact," ",fine," ",good," ",lost," ",acc
                    glBindBuffer(GL_ARRAY_BUFFER, chart.ibo)
                    var ptrNote = glMapBufferRange(GL_ARRAY_BUFFER, (
                        catchingNotes-1)*sizeof(Note), sizeof(Note), GL_MAP_WRITE_BIT or GL_MAP_INVALIDATE_RANGE_BIT)
                    copyMem(ptrNote, chart.notes[catchingNotes-1].addr, sizeof(Note))
                    discard glUnmapBuffer(GL_ARRAY_BUFFER)
                  inc catchingNotes
                else:
                  inc catchingNotes


          while judgedNotes < chart.notes.len and chart.notes[
              judgedNotes].t1-igt < -0.064*judgeFactor:
            if chart.notes[judgedNotes].judged==1:
              acc = (acc*judgedNotes.float+1)/(judgedNotes+1).float
              inc judgedNotes
              continue
            combo = 0
            inc lost
            acc = acc*(judgedNotes/(judgedNotes+1))
            chart.notes[judgedNotes].judged = 1
            inc judgedNotes
            # echo combo," ",maxCombo," ",xExact," ",exact," ",fine," ",good," ",lost," ",acc
            glBindBuffer(GL_ARRAY_BUFFER, chart.ibo)
            var ptrNote = glMapBufferRange(GL_ARRAY_BUFFER, (
                judgedNotes-1)*sizeof(Note), sizeof(Note), GL_MAP_WRITE_BIT or GL_MAP_INVALIDATE_RANGE_BIT)
            copyMem(ptrNote, chart.notes[judgedNotes-1].addr, sizeof(Note))
            discard glUnmapBuffer(GL_ARRAY_BUFFER)
      glBindBuffer(GL_ARRAY_BUFFER, accText.ibo)
      var ptrAcc = glMapBufferRange(GL_ARRAY_BUFFER, 0, 7, GL_MAP_WRITE_BIT or GL_MAP_INVALIDATE_RANGE_BIT)
      var s = fmt"{acc*100:06.2f}%"
      copyMem(ptrAcc, s[0].addr, 7)
      discard glUnmapBuffer(GL_ARRAY_BUFFER)
      glBindBuffer(GL_ARRAY_BUFFER, comboText.ibo)
      var ptrCombo = glMapBufferRange(GL_ARRAY_BUFFER, 0, 12, GL_MAP_WRITE_BIT or GL_MAP_INVALIDATE_RANGE_BIT)
      var s1 = fmt"{combo:12}"
      copyMem(ptrCombo, s1[0].addr, 12)
      discard glUnmapBuffer(GL_ARRAY_BUFFER)

    
      particleRI.updateBuffer(1,256*sizeof(Particle),particles)

      glMemoryBarrier(GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT or GL_BUFFER_UPDATE_BARRIER_BIT)
      glClearColor(0, 0, 0, 1)
      glClear(GL_COLOR_BUFFER_BIT)
      titleText.render(-0.95, -0.85)
      levelText.render(0.95-chart.level.len.float32*(0.05/2), -0.85)
      accText.render(-0.35/4, -0.85)
      comboText.render((floor(log10(combo.float32))-24)*(0.1/4), 0.65,0.1)
      glUseProgram(noteShader)
      glUniformMatrix4fv(uMVP, 1, false, mvp.caddr)
      glUniform1f(uSpeed, speed)
      glUniform1f(uXSF, 0)
      glUniform1f(uFloor, floor)
      glUniform1f(uLinePos, linePos)
      glBindVertexArray(chart.vao)
      glDrawElementsInstanced(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nil, len(
          chart.notes).GLsizei)

      
      
      lineRI.render(1):
        glUniformMatrix4fv(lineRI.uMVP, 1, false, mvp.caddr)
        glUniform1f(lineRI.uLinePos, linePos)
      # glUseProgram(lineShader)
      # glUniformMatrix4fv(uMVPl, 1, false, mvp.caddr)
      # glUniform1f(uLinePosl, linePos)
      # glBindVertexArray(linevao)
      # glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nil)

      particleRI.render(256):
        glUniformMatrix4fv(particleRI.uMVP, 1, false, mvp.caddr)
        glUniform1f(particleRI.uLinePos, linePos)
        glUniform1f(particleRI.uTime, igt)
      # glUseProgram(particleShader)
      # glUniformMatrix4fv(uMVPp, 1, false, mvp.caddr)
      # glUniform1f(uLinePosp, linePos)
      # glUniform1f(uTimep, igt)
      # glBindVertexArray(ptcvao)
      # glDrawElementsInstanced(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nil,256)

      window.swapBuffers()
      lastTime = time
      if musicPlaying():
        endPlayTime=time

    glfwPollEvents()
    case dest
    of 0:
      discard
    of 1:
      return sGamePlay
    else:
      discard
    time = getMonoTime().ticks()
  return sEndGame
